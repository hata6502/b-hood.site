<!DOCTYPE html>
<html lang="ja-jp">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    
    <title>hata6502 Tech Blog</title>
    <meta name="viewport" content="width=device-width,minimum-scale=1">
    <meta name="description" content="">
    <meta name="generator" content="Hugo 0.78.2" />
    
    
      <META NAME="ROBOTS" CONTENT="NOINDEX, NOFOLLOW">
    

    
    
      <link href="/dist/css/app.4fc0b62e4b82c997bb0041217cd6b979.css" rel="stylesheet">
    

    

    
      

    

    
    
      <link href="/articles/index.xml" rel="alternate" type="application/rss+xml" title="hata6502 Tech Blog" />
      <link href="/articles/index.xml" rel="feed" type="application/rss+xml" title="hata6502 Tech Blog" />
      
    
    
    <meta property="og:title" content="Articles" />
<meta property="og:description" content="" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://b-hood.site/articles/" />

<meta itemprop="name" content="Articles">
<meta itemprop="description" content="">
<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Articles"/>
<meta name="twitter:description" content=""/>

	
  </head>

  <body class="ma0 avenir bg-near-white">

    

  <header>
    <div class="pb3-m pb6-l bg-black">
      <nav class="pv3 ph3 ph4-ns" role="navigation">
  <div class="flex-l justify-between items-center center">
    <a href="/" class="f3 fw2 hover-white no-underline white-90 dib">
      
        hata6502 Tech Blog
      
    </a>
    <div class="flex-l items-center">
      

      
      















    </div>
  </div>
</nav>

      <div class="tc-l pv3 ph3 ph4-ns">
        <h1 class="f2 f-subheadline-l fw2 light-silver mb0 lh-title">
          Articles
        </h1>
        
      </div>
    </div>
  </header>


    <main class="pb7" role="main">
      
  <article class="pa3 pa4-ns nested-copy-line-height nested-img">
    <section class="cf ph3 ph5-l pv3 pv4-l f4 tc-l center measure-wide lh-copy mid-gray"></section>
    <section class="flex-ns flex-wrap justify-around mt5">
      
        <div class="relative w-100 w-30-l mb4 bg-white"><div class="relative w-100 mb4 bg-white nested-copy-line-height">
  <div class="bg-white mb3 pa4 gray overflow-hidden">
    <span class="f6 db">Articles</span>
    <h1 class="f3 near-black">
      <a href="https://b-hood.site/articles/editor-js-grid/" class="link black dim">
        How to make grid layout in Editor.js
      </a>
    </h1>
    <div class="nested-links f5 lh-copy nested-copy-line-height">
      &lt;ins class=&ldquo;adsbygoogle&rdquo; style=&ldquo;display:block&quot;ｌｓ data-ad-client=&ldquo;ca-pub-7008780049786244&rdquo; data-ad-slot=&ldquo;5063315418&rdquo; data-ad-format=&ldquo;auto&rdquo; data-full-width-responsive=&ldquo;true&rdquo;&gt;Use Editor.js more flexibly Editor.js is one of block editors. The article data format is JSON not HTML, so it can manage article data more cleanly and formally.
Editor.js can&rsquo;t nest blocks to keep simplicity. So it is useful for general articles that blogs, news and so on. But difficult for special layout that landing page and so on.
Therefore, I published a grid layout plugin for Editor.
    </div>
  </div>
</div>
</div>
      
        <div class="relative w-100 w-30-l mb4 bg-white"><div class="relative w-100 mb4 bg-white nested-copy-line-height">
  <div class="bg-white mb3 pa4 gray overflow-hidden">
    <span class="f6 db">Articles</span>
    <h1 class="f3 near-black">
      <a href="https://b-hood.site/articles/trimrate/" class="link black dim">
        ImageMagickで16:9トリミングを自動化
      </a>
    </h1>
    <div class="nested-links f5 lh-copy nested-copy-line-height">
      皆さんは画像を SNS や自身のブログなどに投稿する際に加工したことはないでしょうか？ Twitter では画像が自動的に 16:9 で表示されるため、あらかじめ 16:9 でトリミングしておくことでどのように表示されるかを調整できます。 トリミング機能は Android 版にはありますが Web 版にはないため、PC からの画像投稿のときに少し面倒に感じたりします。
画像編集の自動化といえば ImageMagick そこで GIMP などの画像編集ソフトが必要になりますが、私は ImageMagick を利用しています。 画像の加工を自動で行うためのコマンドラインが用意されており、たとえば以下のようにすれば png ファイルを一括で余白トリミングできます。 GIMP でいう「最小枠で切り抜き」機能ですね。
画像サイズを指定しての切り抜きは ImageMagick の crop オプションを使います。 座標 (X, Y) の位置で幅 W px、高さ H px のトリミングをするには以下のコマンドを打ちます。
しかし、残念ながら比率（16:9 など）の指定によるトリミングには対応していません。 そこで、比率指定によるトリミングのコマンドをシェルスクリプトで作りました。
trimrate コマンドを作ってみた 結論から言うと、比率指定によるトリミングコマンドを以下のように作りました。
このシェルスクリプトを trimrate というファイル名で保存します。 保存先は /usr/local/bin などのパスが通っているところが便利です。 そして chmod +x trimrate で実行権限を与えて以下の構文でトリミングを行います。
コマンドの動作的には、比率から切り抜きの幅高さを計算して ImageMagick の crop 機能を呼び出しているだけです。 デフォルトだと画像の上部でトリミングするため、-gravity center オプションを加えて中央でトリミングしています。
for 文で一括処理する trimrate コマンドだけだと mogrify のように複数のファイルを一括処理できません。 しかし、bash の for 文で画像ファイルごとに trimrate を実行して一括処理させることはできます。
    </div>
  </div>
</div>
</div>
      
        <div class="relative w-100 w-30-l mb4 bg-white"><div class="relative w-100 mb4 bg-white nested-copy-line-height">
  <div class="bg-white mb3 pa4 gray overflow-hidden">
    <span class="f6 db">Articles</span>
    <h1 class="f3 near-black">
      <a href="https://b-hood.site/articles/webp/" class="link black dim">
        webp 画像形式でファイルサイズが 92% 削減された
      </a>
    </h1>
    <div class="nested-links f5 lh-copy nested-copy-line-height">
      皆さんこんにちは 😀 私はいま作っているこのサイトでは、シンプルかつこだわりをもってあれこれやっているつもりです。 そのひとつとして、Google の PageSpeed Insightsというものを利用しています。 これはページの読み込み速度をスコアリングして、さらにスピードを改善するためのアドバイスもしてくれるすばらしいツールです。 ページスピードは Web 検索にも影響すると言われ、サイトを運営している方であれば多くの人が活用できるのではないでしょうか？ この記事では、読み込み速度改善の 1 つとしてWebp 画像形式の導入について紹介したいと思います。
まずはページスピードを測定 まずは自分の Web サイトの状況を確認するために、PageSpeed Insights を使います。 サイトの URL を入力して測定するだけで、数十秒後にはスコアが表示されると思います。 なお、PageSpeed Insights はモバイルと PC に分けて測定、スコアリングするため、両方確認する必要があります。
私のサイトでは、まず重要な箇所としてランディングページ (LP) の測定をしてみました。 LP には特にコンテンツもなく負荷が軽いので、スコア 90 点超えの良い結果となりました。
しかし、記事一覧ページでは 80 点台という標準的な結果でした。
こんなとき、Google はスピード改善のための提案をしてくれます。 そこに「次世代フォーマットでの画像の配信」というものがありました。 これは、Web サイトに埋め込まれている jpg や png などの形式の画像を、 jpeg2000 や Webp という画像形式に置き換えることで通信負荷が抑えられることを意味しています。 さらに、次世代フォーマットを導入することによるファイルサイズの削減量まで教えてくれるといういたわり尽くせリです。
Webp 形式に変換する というわけで、さっそく Web サイト中のあらゆる png, JPEG ファイルを Webp に変換してみました。 Ubuntu をお使いの方は、以下のコマンドで Webp に変換するコマンドをインストールできます。
そして、以下のコマンドで png, JPEG ファイルを一括で Webp ファイルに変換できます。 なお、cwebp コマンドは変換のクオリティがデフォルトで 80% に設定されています。 コマンドオプションを追加して、クオリティを変更することも可能です。
    </div>
  </div>
</div>
</div>
      
        <div class="relative w-100 w-30-l mb4 bg-white"><div class="relative w-100 mb4 bg-white nested-copy-line-height">
  <div class="bg-white mb3 pa4 gray overflow-hidden">
    <span class="f6 db">Articles</span>
    <h1 class="f3 near-black">
      <a href="https://b-hood.site/articles/staticgen/" class="link black dim">
        「静的サイトジェネレータ」という言葉だけで静的サイトを作った話
      </a>
    </h1>
    <div class="nested-links f5 lh-copy nested-copy-line-height">
      皆さんこんにちは。 私はつい最近静的サイトジェネレータという言葉を聞きました。 「静的」に興味を惹かれた私が、静的サイトジェネレータという言葉だけで静的サイトを作ってみた話をまとめます。 今回の記事は私の憶測が多いのでご注意ください（笑）
なお、当サイトはこの記事の通りに Laravel &amp; wget &amp; nginx による静的サイトとなっています。 もしご興味があれば、GitHubを見ていただけると幸いです。
静的サイトとは？ まず、静的サイトの意味から考える必要があります。 おそらくこれは静的なサイト、つまりリクエストに対して Web サーバのレスポンスコンテンツが変わらないということです。 ということは、HTML, CSS, 画像アセットなどの静的なファイルを提供するだけのサイトであれば広義の静的サイトに当てはまります。
静的サイトのメリット・デメリット ただ html を提供するだけの静的サイトであれば、なんだかインターネット初期の &lsquo;90 年代のように感じてしまいます。 そこで、静的サイトのメリットをまとめてみました。
 Web サーバが PHP などを実行することはないため、動的コンテンツによる脆弱性が存在しない。 すでにレスポンスコンテンツが用意されているため、高速である。 レンタルサーバなどでは PHP を実行できない場合も多く、静的サイトであればサーバに求める要件が低い。  次に、静的サイトのデメリットをまとめます。
 端末（スマートフォン、PC など）によってサーバレスポンスを変化させることは難しい。 REST API や検索機能などの提供は不可能。  静的サイトジェネレータとは？ 静的サイトの意味が定まったところで、次は静的サイトジェネレータについて考えます。 これは静的サイトを作る、つまり静的サイトを作る元データがあり、それを加工して静的コンテンツを作るツールと考えられます。 ということは PHP で動的コンテンツを作り、それを php コマンドで html 出力して Web サーバで公開すれば、 PHP は静的サイトジェネレータになるということです。 逆に、アクセスがあった時点で PHP を実行して html を出力するのであれば、PHP は動的サイトのエンジンやエグゼキュータと呼べるのでしょう。
クローラは静的サイトジェネレータ？ 以上のことを踏まえると、どんな動的コンテンツでも、サーバからダウンロードしたときには静的コンテンツになっていることになります。 JavaScript による DOM 操作などは、サーバとしては静的であるとみなします。 よって、ローカルな開発環境で動的サイトのサーバを立ち上げ、それをクローラで html として取得すれば、 クローラは静的サイトジェネレータということになります。
    </div>
  </div>
</div>
</div>
      
        <div class="relative w-100 w-30-l mb4 bg-white"><div class="relative w-100 mb4 bg-white nested-copy-line-height">
  <div class="bg-white mb3 pa4 gray overflow-hidden">
    <span class="f6 db">Articles</span>
    <h1 class="f3 near-black">
      <a href="https://b-hood.site/articles/pre_commit/" class="link black dim">
        【CI】git commit 時に自動整形 &amp; コーディングチェックする
      </a>
    </h1>
    <div class="nested-links f5 lh-copy nested-copy-line-height">
      皆さんこんにちは。 プログラミングやコーディングを続けていくうちに、過去に自分が書いたコードの意味が分からなくなったりしたことはないでしょうか？ 今回は、中〜大規模な開発をする際に重要な**サーバレスな継続的インテグレーション（CI）**について書きたいと思います。
導入方法はこちら
継続的インテグレーション（CI）とは WikiPedia継続的インテグレーション（CI）とは、ソフトウェア開発においてソースコードの品質や保守性を保ち、持続可能な開発を続けていくための方法です。 つまり、ほかの人が見ても理解しやすく、また自分が書いた古いコードでも処理内容が理解できるようにプログラミングしていくということですね。
個人の趣味のスクリプトであれば CI を導入する必要はないかもしれません。 しかし、お仕事などでのチームでの開発では重要になると思います。 また GitHub で公開するものに対しても、CI を導入するとメリットが大きいと思います。
ソースコードの属人性（その人にしか分からないような書き方）を解消するために、開発ルールを定めることがあります。 たとえば、コーディングスタイルを定義したり（Google C++ Style Guide など）、コードレビューをするなどです。 これらは整形ツールやコーディングチェック（lint）を使って自動化できます。
サーバレスで CI を導入 CI を導入する方法として、CI サーバを立てる方法があります。 たとえば、GitHub では Travis CI を導入することで、git commit 時に自動で CI を実行してくれます。 さらに、CI の実行結果を GitHub のバッジ として公言でき、リポジトリの質を保証する 1 つの指標にできます。
しかし、CI サービスは有料プランのものもあり（Public リポジトリは無料も）、特に社内開発ではコストになる場合があります。 そこで、CI をローカル環境に導入し、git commit 時に自動でコーディングチェックと自動整形をしたいと思います。
pre_commit フックを使う Git には、コミット時などにスクリプトを実行するフック機能があります。 その 1 つに pre_commit というものがあり、これはコミットをする直前に発動します。 よって、pre_commit に CI のプログラムを記述することで、git commit したときにコーディングチェックや自動整形を実行できます。
自動化ツール コーディングチェックや自動整形を行うコマンドラインツールです。
 clang-format　C/C++ の自動整形をします。 cpplint　C/C++ の静的コード解析をします。 Prettier　HTML, CSS, JavaScript, PHP, Markdown, Yaml などの自動整形をします。 ESLint　JavaScript の静的コード解析をします。 phpmd　PHP の静的コード解析をします。  pre_commit 例 私が開発するときに導入している Git フックは、このリポジトリで公開しています。 blue-hood/.
    </div>
  </div>
</div>
</div>
      
        <div class="relative w-100 w-30-l mb4 bg-white"><div class="relative w-100 mb4 bg-white nested-copy-line-height">
  <div class="bg-white mb3 pa4 gray overflow-hidden">
    <span class="f6 db">Articles</span>
    <h1 class="f3 near-black">
      <a href="https://b-hood.site/articles/gitwitter/" class="link black dim">
        【Git×Twitter】連携 &amp;amp; 通知してコミットの質を上げよう
      </a>
    </h1>
    <div class="nested-links f5 lh-copy nested-copy-line-height">
      いつも私は Git のコミットメッセージを適当に済ませてしまうのですが、git push するとツイートされるしくみを導入したらコミットメッセージの質が格段に上がりました。
導入前
導入後
（英語から日本語に変わっているのはさておき、）コミットメッセージの内容が具体的になりました。また、Twitter を意識してかちょっと感情的なところもちらほらありますね。このような Git と Twitter の連携をサーバレスで導入する方法を紹介します。
インストール方法
2019/03/30 gitwitter のレアケース対策をしました。
Webhook は意外と不便 Git と Twitter の連携でメジャーと思われるのは、Webhook を利用する方法です。GitHub や Bitbucket には、リポジトリへの push イベントごとに POST リクエストを投げてくれる機能があります。それを別途 Web サーバで拾ってツイートします。いわゆるクラウドハブはこの機能を利用しているわけですね。
しかし、クラウドハブを利用するには月額料金がかかったり、無料だとしても月ごとの使用回数に制限があったりします。また自前で Webhook を拾うには、サーバが必要なのはもちろん HTTPS 通信をするためのドメインと証明書なども必要になります。Git の push をツイートするためだけに Webhook を利用するのは、ちょっとオーバーな気がします。
また、実際に私が Webhook を導入してみて思ったのは、ツイートするかを毎回制御できないため不便だということです。たとえば、タイポを修正するだけのささいな push に対してもツイートされてしまい、手動で無駄なツイートを消すということがありました。タイムラインを荒らしてしまったと思いますね。
サーバレスで連携する そこで、Webhook を使わずクライアントで動かす連携アプリケーションを作ることにしました。これならサーバレスだしツイートするかも毎回決めることができます。ツイートする文章はシェルスクリプトで git log を呼び出したりして組み立てました。ツイートするには TwitterOAuth を使って Twitter REST API をたたく PHP スクリプトを書きました。使い方はこんな感じです。
tweet コマンド GitHub: Hata6502/tweet
コマンドラインからツイートします。標準入力から読み込む汎用的な作りにしたので、Git との連携以外にも応用できるかもしれません。
(1) /usr/local/src などにダウンロードします。
    </div>
  </div>
</div>
</div>
      
        <div class="relative w-100 w-30-l mb4 bg-white"><div class="relative w-100 mb4 bg-white nested-copy-line-height">
  <div class="bg-white mb3 pa4 gray overflow-hidden">
    <span class="f6 db">Articles</span>
    <h1 class="f3 near-black">
      <a href="https://b-hood.site/articles/table-of-contents/" class="link black dim">
        【jQuery不要】JS で章番号 &amp; リンク付きの目次を自動生成する
      </a>
    </h1>
    <div class="nested-links f5 lh-copy nested-copy-line-height">
      WordPress 製のサイトなどで見かける目次。 そのページの内容がリストとして一目で確認できるため、Web サイトにも大きな役割を果たします。 JavaScript で目次を自動生成する方法を紹介します。
JavaScript で目次を作る 基本的に見出しは h1〜h6 でタグ付けされているかと思います。 これらのタグには見出しという情報だけでなく、見出しどうしの階層関係も表現されています。 よって、h1〜h6 タグは目次を作るのに最適な情報源と言えます。
目次を置く場所に &lt;ol class=&quot;table-of-contents&quot;&gt;&lt;/ol&gt; を配置して、この要素の中に JavaScript で目次の情報を書き込んでいきます。
上記が目次を自動生成する JavaScript の完成形になります。
QuerySelectorAll で h1〜h6 タグを探す まずは .table-of-contents を設置した親要素から、h1〜h6 要素を探し出します。
h1〜h6 タグを元に目次要素を生成 探し出した h1〜h6 タグが変数 heading に入ってループ処理されているとします。 まずは目次 1 行分に相当する li 要素を生成し、その中に a 要素と ol 要素を入れています。 a 要素には h1〜h6 のテキストを入れて、さらにアンカーリンクとして href 属性に #section-${table_of_contents_counter++} を入れています。 変数 table_of_contents_counter は 1、2、3…と増分していくので、生成されるアンカーリンクも #section-1、#section-2、…となります。 ol 要素は、見出しの階層構造を作るために後で必要となります。
h1〜h6 タグにアンカーリンクも紐付け 生成したアンカーリンクを h1〜h6 タグの id に設定します。 これによって、目次の要素をクリックしたときにページ内ジャンプさせます。 さらに、必要であれば anchor-link クラスを付けて CSS でデザイン調整しましょう。
    </div>
  </div>
</div>
</div>
      
        <div class="relative w-100 w-30-l mb4 bg-white"><div class="relative w-100 mb4 bg-white nested-copy-line-height">
  <div class="bg-white mb3 pa4 gray overflow-hidden">
    <span class="f6 db">Articles</span>
    <h1 class="f3 near-black">
      <a href="https://b-hood.site/articles/husky/" class="link black dim">
        【PHPMD 対応】husky &amp;amp; lint-staged で CI を実行する
      </a>
    </h1>
    <div class="nested-links f5 lh-copy nested-copy-line-height">
      みなさんこんにちは、今回は husky と lint-staged を使って CI 環境をローカルに構築する方法を紹介したいと思います。
継続的インテグレーション（CI）とは WikiPedia継続的インテグレーション（CI）とは、ソフトウェア開発においてソースコードの品質や保守性を保ち、持続可能な開発を続けていくための方法です。 つまり、ほかの人が見ても理解しやすく、また自分が書いた古いコードでも処理内容が理解できるようにプログラミングしていくということですね。
個人の趣味のスクリプトであれば CI を導入する必要はないかもしれませんが、お仕事などでのチームでの開発では重要になると思います。 また GitHub で公開するものに対しても、CI を導入するとメリットが大きいと思います。
ソースコードの属人性（その人にしか分からないような書き方）を解消するために、開発ルールを定めることがあります。 たとえば、コーディングスタイルを定義したり（Google C++ Style Guide など）、コードレビューをするなどです。 これらは整形ツールやコーディングチェック（lint）を使って自動化できます。
サーバレスで CI を導入 CI を導入する方法として、CI サーバを立てる方法があります。 たとえば、GitHub では Travis CI を導入することで、git commit 時に自動で CI を実行してくれます。 さらに、CI の実行結果を GitHub のバッジ として公言でき、リポジトリの質を保証する 1 つの指標にできます。
しかし、CI サービスは有料プランのものもあり（Public リポジトリは無料も）、特に社内開発ではコストになる場合があります。 そこで、CI をローカル環境に導入し、git commit 時に自動でコーディングチェックと自動整形をしたいと思います。
huskey と lint-staged を使うメリット コミット時に CI スクリプトを実行するには pre-commit を自前で記述することも可能です。 しかし、ほかの人と共同開発する場合では手動で pre-commit および自動整形ツール（prettier や eslint）を導入する必要がありました。
そこで、husky を使って pre-commit をフックし、lint-staged でコーディングチェックと自動整形を実行させたいと思います。 リポジトリ直下に npm で husky、lint-staged、prettier、eslint などをインストールすれば、以降は npm install だけで CI 環境が整います。
    </div>
  </div>
</div>
</div>
      
        <div class="relative w-100 w-30-l mb4 bg-white"><div class="relative w-100 mb4 bg-white nested-copy-line-height">
  <div class="bg-white mb3 pa4 gray overflow-hidden">
    <span class="f6 db">Articles</span>
    <h1 class="f3 near-black">
      <a href="https://b-hood.site/articles/postit-program/" class="link black dim">
        ふせんプログラミング
      </a>
    </h1>
    <div class="nested-links f5 lh-copy nested-copy-line-height">
      物の整理をしていたらおもしろい資料が出てきたので公開します。
&lt;ins class=&ldquo;adsbygoogle&rdquo; style=&ldquo;display:block&quot;ｌｓ data-ad-client=&ldquo;ca-pub-7008780049786244&rdquo; data-ad-slot=&ldquo;5063315418&rdquo; data-ad-format=&ldquo;auto&rdquo; data-full-width-responsive=&ldquo;true&rdquo;&gt;ふせんプログラミングによるバイナリエディタのプログラム。 確か Z80 か 8080 だったような。
    </div>
  </div>
</div>
</div>
      
        <div class="relative w-100 w-30-l mb4 bg-white"><div class="relative w-100 mb4 bg-white nested-copy-line-height">
  <div class="bg-white mb3 pa4 gray overflow-hidden">
    <span class="f6 db">Articles</span>
    <h1 class="f3 near-black">
      <a href="https://b-hood.site/articles/sitemap/" class="link black dim">
        シェルで lastmod changefreq 付きの sitemap.xml を作る
      </a>
    </h1>
    <div class="nested-links f5 lh-copy nested-copy-line-height">
      こんにちは、今回は内容の濃い記事が書けそうでワクワクしています😀　このサイトでは、PHP を使わず静的な html でコンテンツを配信しています。 せっかく作っている Web サイト、この存在をクローラに気づかせるためには sitemap.xml の設置が重要となります。 今回は、sitemap.xml を自動的かつ**こだわりをもって(?)**生成する方法を紹介します。
このサイトの sitemap.xml2019/05/04 sitemap.xml を生成するコマンドを作りました！GitHub
sitemap.xml の構造 sitemap.xml は、そのサイトのサイトマップを表す xml ファイルです。 一般的にドキュメントルートに設置して、robots.txt で sitemap.xml の場所を指定します。
robots.txt の例
sitemap.xml はさらに別の xml ファイルに分割することもできるのですが、 1 ファイルにすべてのページの情報を書き込むとするとこのような形式になります。
url タグで 1 ページ分の情報として列記していきます。 url タグ内の情報を以下のようにまとめました。
 loc: ページの URL(必須） lastmod: ページの最終更新日時（任意） changefreq: ページの更新頻度（任意、hourly, daily, weekly, monthly, yearly など） (priority): そのページの重要度（任意、今回は省略）  最低限の sitemap.xml を作るのであれば、loc だけを書いて簡易的に済ませることもできます。 しかし、できれば lastmod と changefreq も書いてサイトの情報を詳しく伝えたいところです。 ちなみに priority はページの重要度を 0.0〜1.0 の範囲内で指定できるのですが、Google はこの値を無視しているそうです。 まあ、私としても priority は主観的であいまいなデータですし、あまりあてにならないかなと思います。 もちろん全部のページを priority=1.
    </div>
  </div>
</div>
</div>
      
    </section>
<ul class="pagination">
  <li class="page-item">
    <a href="/articles/" class="page-link" aria-label="First"><span aria-hidden="true">&laquo;&laquo;</span></a>
  </li>
  <li class="page-item disabled">
    <a  class="page-link" aria-label="Previous"><span aria-hidden="true">&laquo;</span></a>
  </li>
  <li class="page-item active">
    <a class="page-link" href="/articles/">1</a>
  </li>
  <li class="page-item">
    <a class="page-link" href="/articles/page/2/">2</a>
  </li>
  <li class="page-item">
    <a href="/articles/page/2/" class="page-link" aria-label="Next"><span aria-hidden="true">&raquo;</span></a>
  </li>
  <li class="page-item">
    <a href="/articles/page/2/" class="page-link" aria-label="Last"><span aria-hidden="true">&raquo;&raquo;</span></a>
  </li>
</ul>

</article>

    </main>
    <footer class="bg-black bottom-0 w-100 pa3" role="contentinfo">
  <div class="flex justify-between">
  <a class="f4 fw4 hover-white no-underline white-70 dn dib-ns pv2 ph3" href="https://b-hood.site/" >
    &copy;  hata6502 Tech Blog 2020 
  </a>
    <div>














</div>
  </div>
</footer>

    

  <script src="/dist/js/app.3fc0f988d21662902933.js"></script>


  </body>
</html>
