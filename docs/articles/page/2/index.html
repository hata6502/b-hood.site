<!doctype html><html lang=ja dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Articles - B-Hood Tech Blog</title><meta name=keywords content><meta name=description content><meta name=author content="Tomoyuki Hata"><link rel=canonical href=https://b-hood.site/articles/><link href=https://b-hood.site/assets/css/stylesheet.min.08d6f2005b6ce4ed10207916c0411c66e66f2201e3f7a56e8fb2ccbc4a8b259c.css integrity="sha256-CNbyAFts5O0QIHkWwEEcZuZvIgHj96Vuj7LMvEqLJZw=" rel="preload stylesheet" as=style><link rel=icon href=https://b-hood.site/favicon.png><link rel=icon type=image/png sizes=16x16 href=https://b-hood.site/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://b-hood.site/favicon-32x32.png><link rel=apple-touch-icon href=https://b-hood.site/favicon.png><link rel=mask-icon href=https://b-hood.site/favicon.png><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><meta name=generator content="Hugo 0.78.2"><link rel=alternate type=application/rss+xml href=https://b-hood.site/articles/index.xml><script type=application/javascript>var doNotTrack=false;if(!doNotTrack){window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;ga('create','G-LKJ5YTFF5L','auto');ga('send','pageview');}</script><script async src=https://www.google-analytics.com/analytics.js></script><meta property="og:title" content="Articles"><meta property="og:description" content><meta property="og:type" content="website"><meta property="og:url" content="https://b-hood.site/articles/"><meta property="og:image" content="https://b-hood.site/47"><meta property="og:updated_time" content="2020-11-21T22:19:40+09:00"><meta property="og:site_name" content="B-Hood Tech Blog"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://b-hood.site/47"><meta name=twitter:title content="Articles"><meta name=twitter:description content></head><body class=list id=top><script>if(localStorage.getItem("pref-theme")==="dark"){document.body.classList.add('dark');}else if(localStorage.getItem("pref-theme")==="light"){document.body.classList.remove('dark')}else if(window.matchMedia('(prefers-color-scheme: dark)').matches){document.body.classList.add('dark');}</script><noscript><style type=text/css>.theme-toggle,.top-link{display:none}</style></noscript><header class=header><nav class=nav><div class=logo><a href=https://b-hood.site/ accesskey=h><img src=/favicon.png alt=logo aria-label=logo height=35>B-Hood Tech Blog</a>
<span class=logo-switches><span class=theme-toggle><a id=theme-toggle accesskey=t><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></a></span></span></div><ul class=menu id=menu onscroll=menu_on_scroll()></ul></nav></header><main class=main><header class=page-header><h1>Articles</h1></header><article class=post-entry><header class=entry-header><h2>【アーカイブ】「静的サイトジェネレータ」という言葉だけで静的サイトを作った話</h2></header><section class=entry-content><p>皆さんこんにちは。 私はつい最近静的サイトジェネレータという言葉を聞きました。 「静的」に興味を惹かれた私が、静的サイトジェネレータという言葉だけで静的サイトを作ってみた話をまとめます。 今回の記事は私の憶測が多いのでご注意ください（笑）
なお、当サイトはこの記事の通りに Laravel & wget & nginx による静的サイトとなっています。 もしご興味があれば、GitHubを見ていただけると幸いです。
静的サイトとは？ まず、静的サイトの意味から考える必要があります。 おそらくこれは静的なサイト、つまりリクエストに対して Web サーバのレスポンスコンテンツが変わらないということです。 ということは、HTML, CSS, 画像アセットなどの静的なファイルを提供するだけのサイトであれば広義の静的サイトに当てはまります。
静的サイトのメリット・デメリット ただ html を提供するだけの静的サイトであれば、なんだかインターネット初期の ‘90 年代のように感じてしまいます。 そこで、静的サイトのメリットをまとめてみました。
Web サーバが PHP などを実行することはないため、動的コンテンツによる脆弱性が存在しない。 すでにレスポンスコンテンツが用意されているため、高速である。 レンタルサーバなどでは PHP を実行できない場合も多く、静的サイトであればサーバに求める要件が低い。 次に、静的サイトのデメリットをまとめます。
端末（スマートフォン、PC など）によってサーバレスポンスを変化させることは難しい。 REST API や検索機能などの提供は不可能。 静的サイトジェネレータとは？ 静的サイトの意味が定まったところで、次は静的サイトジェネレータについて考えます。 これは静的サイトを作る、つまり静的サイトを作る元データがあり、それを加工して静的コンテンツを作るツールと考えられます。 ということは PHP で動的コンテンツを作り、それを php コマンドで html 出力して Web サーバで公開すれば、 PHP は静的サイトジェネレータになるということです。 逆に、アクセスがあった時点で PHP を実行して html を出力するのであれば、PHP は動的サイトのエンジンやエグゼキュータと呼べるのでしょう。
クローラは静的サイトジェネレータ？ 以上のことを踏まえると、どんな動的コンテンツでも、サーバからダウンロードしたときには静的コンテンツになっていることになります。 JavaScript による DOM 操作などは、サーバとしては静的であるとみなします。 よって、ローカルな開発環境で動的サイトのサーバを立ち上げ、それをクローラで html として取得すれば、 クローラは静的サイトジェネレータということになります。...</p></section><footer class=entry-footer>1 min&nbsp;·&nbsp;Tomoyuki Hata</footer><a class=entry-link aria-label="post link to 【アーカイブ】「静的サイトジェネレータ」という言葉だけで静的サイトを作った話" href=https://b-hood.site/articles/staticgen/></a></article><article class=post-entry><header class=entry-header><h2>【アーカイブ】【CI】git commit 時に自動整形 & コーディングチェックする</h2></header><section class=entry-content><p>皆さんこんにちは。 プログラミングやコーディングを続けていくうちに、過去に自分が書いたコードの意味が分からなくなったりしたことはないでしょうか？ 今回は、中〜大規模な開発をする際に重要な**サーバレスな継続的インテグレーション（CI）**について書きたいと思います。
導入方法はこちら
継続的インテグレーション（CI）とは WikiPedia継続的インテグレーション（CI）とは、ソフトウェア開発においてソースコードの品質や保守性を保ち、持続可能な開発を続けていくための方法です。 つまり、ほかの人が見ても理解しやすく、また自分が書いた古いコードでも処理内容が理解できるようにプログラミングしていくということですね。
個人の趣味のスクリプトであれば CI を導入する必要はないかもしれません。 しかし、お仕事などでのチームでの開発では重要になると思います。 また GitHub で公開するものに対しても、CI を導入するとメリットが大きいと思います。
ソースコードの属人性（その人にしか分からないような書き方）を解消するために、開発ルールを定めることがあります。 たとえば、コーディングスタイルを定義したり（Google C++ Style Guide など）、コードレビューをするなどです。 これらは整形ツールやコーディングチェック（lint）を使って自動化できます。
サーバレスで CI を導入 CI を導入する方法として、CI サーバを立てる方法があります。 たとえば、GitHub では Travis CI を導入することで、git commit 時に自動で CI を実行してくれます。 さらに、CI の実行結果を GitHub のバッジ として公言でき、リポジトリの質を保証する 1 つの指標にできます。
しかし、CI サービスは有料プランのものもあり（Public リポジトリは無料も）、特に社内開発ではコストになる場合があります。 そこで、CI をローカル環境に導入し、git commit 時に自動でコーディングチェックと自動整形をしたいと思います。
pre_commit フックを使う Git には、コミット時などにスクリプトを実行するフック機能があります。 その 1 つに pre_commit というものがあり、これはコミットをする直前に発動します。 よって、pre_commit に CI のプログラムを記述することで、git commit したときにコーディングチェックや自動整形を実行できます。
自動化ツール コーディングチェックや自動整形を行うコマンドラインツールです。
clang-format　C/C++ の自動整形をします。 cpplint　C/C++ の静的コード解析をします。 Prettier　HTML, CSS, JavaScript, PHP, Markdown, Yaml などの自動整形をします。 ESLint　JavaScript の静的コード解析をします。 phpmd　PHP の静的コード解析をします。 pre_commit 例 私が開発するときに導入している Git フックは、このリポジトリで公開しています。 blue-hood/....</p></section><footer class=entry-footer>1 min&nbsp;·&nbsp;Tomoyuki Hata</footer><a class=entry-link aria-label="post link to 【アーカイブ】【CI】git commit 時に自動整形 & コーディングチェックする" href=https://b-hood.site/articles/pre_commit/></a></article><article class=post-entry><header class=entry-header><h2>【アーカイブ】【Git×Twitter】連携 &amp;amp; 通知してコミットの質を上げよう</h2></header><section class=entry-content><p>いつも私は Git のコミットメッセージを適当に済ませてしまうのですが、git push するとツイートされるしくみを導入したらコミットメッセージの質が格段に上がりました。
導入前
導入後
（英語から日本語に変わっているのはさておき、）コミットメッセージの内容が具体的になりました。また、Twitter を意識してかちょっと感情的なところもちらほらありますね。このような Git と Twitter の連携をサーバレスで導入する方法を紹介します。
インストール方法
2019/03/30 gitwitter のレアケース対策をしました。
Webhook は意外と不便 Git と Twitter の連携でメジャーと思われるのは、Webhook を利用する方法です。GitHub や Bitbucket には、リポジトリへの push イベントごとに POST リクエストを投げてくれる機能があります。それを別途 Web サーバで拾ってツイートします。いわゆるクラウドハブはこの機能を利用しているわけですね。
しかし、クラウドハブを利用するには月額料金がかかったり、無料だとしても月ごとの使用回数に制限があったりします。また自前で Webhook を拾うには、サーバが必要なのはもちろん HTTPS 通信をするためのドメインと証明書なども必要になります。Git の push をツイートするためだけに Webhook を利用するのは、ちょっとオーバーな気がします。
また、実際に私が Webhook を導入してみて思ったのは、ツイートするかを毎回制御できないため不便だということです。たとえば、タイポを修正するだけのささいな push に対してもツイートされてしまい、手動で無駄なツイートを消すということがありました。タイムラインを荒らしてしまったと思いますね。
サーバレスで連携する そこで、Webhook を使わずクライアントで動かす連携アプリケーションを作ることにしました。これならサーバレスだしツイートするかも毎回決めることができます。ツイートする文章はシェルスクリプトで git log を呼び出したりして組み立てました。ツイートするには TwitterOAuth を使って Twitter REST API をたたく PHP スクリプトを書きました。使い方はこんな感じです。
tweet コマンド GitHub: Hata6502/tweet
コマンドラインからツイートします。標準入力から読み込む汎用的な作りにしたので、Git との連携以外にも応用できるかもしれません。
(1) /usr/local/src などにダウンロードします。...</p></section><footer class=entry-footer>1 min&nbsp;·&nbsp;Tomoyuki Hata</footer><a class=entry-link aria-label="post link to 【アーカイブ】【Git×Twitter】連携 &amp;amp; 通知してコミットの質を上げよう" href=https://b-hood.site/articles/gitwitter/></a></article><article class=post-entry><header class=entry-header><h2>【アーカイブ】【jQuery不要】JS で章番号 & リンク付きの目次を自動生成する</h2></header><section class=entry-content><p>WordPress 製のサイトなどで見かける目次。 そのページの内容がリストとして一目で確認できるため、Web サイトにも大きな役割を果たします。 JavaScript で目次を自動生成する方法を紹介します。
JavaScript で目次を作る 基本的に見出しは h1〜h6 でタグ付けされているかと思います。 これらのタグには見出しという情報だけでなく、見出しどうしの階層関係も表現されています。 よって、h1〜h6 タグは目次を作るのに最適な情報源と言えます。
目次を置く場所に &lt;ol class="table-of-contents">&lt;/ol> を配置して、この要素の中に JavaScript で目次の情報を書き込んでいきます。
上記が目次を自動生成する JavaScript の完成形になります。
QuerySelectorAll で h1〜h6 タグを探す まずは .table-of-contents を設置した親要素から、h1〜h6 要素を探し出します。
h1〜h6 タグを元に目次要素を生成 探し出した h1〜h6 タグが変数 heading に入ってループ処理されているとします。 まずは目次 1 行分に相当する li 要素を生成し、その中に a 要素と ol 要素を入れています。 a 要素には h1〜h6 のテキストを入れて、さらにアンカーリンクとして href 属性に #section-${table_of_contents_counter++} を入れています。 変数 table_of_contents_counter は 1、2、3…と増分していくので、生成されるアンカーリンクも #section-1、#section-2、…となります。 ol 要素は、見出しの階層構造を作るために後で必要となります。
h1〜h6 タグにアンカーリンクも紐付け 生成したアンカーリンクを h1〜h6 タグの id に設定します。 これによって、目次の要素をクリックしたときにページ内ジャンプさせます。 さらに、必要であれば anchor-link クラスを付けて CSS でデザイン調整しましょう。...</p></section><footer class=entry-footer>1 min&nbsp;·&nbsp;Tomoyuki Hata</footer><a class=entry-link aria-label="post link to 【アーカイブ】【jQuery不要】JS で章番号 & リンク付きの目次を自動生成する" href=https://b-hood.site/articles/table-of-contents/></a></article><article class=post-entry><header class=entry-header><h2>【アーカイブ】【PHPMD 対応】husky &amp;amp; lint-staged で CI を実行する</h2></header><section class=entry-content><p>みなさんこんにちは、今回は husky と lint-staged を使って CI 環境をローカルに構築する方法を紹介したいと思います。
継続的インテグレーション（CI）とは WikiPedia継続的インテグレーション（CI）とは、ソフトウェア開発においてソースコードの品質や保守性を保ち、持続可能な開発を続けていくための方法です。 つまり、ほかの人が見ても理解しやすく、また自分が書いた古いコードでも処理内容が理解できるようにプログラミングしていくということですね。
個人の趣味のスクリプトであれば CI を導入する必要はないかもしれませんが、お仕事などでのチームでの開発では重要になると思います。 また GitHub で公開するものに対しても、CI を導入するとメリットが大きいと思います。
ソースコードの属人性（その人にしか分からないような書き方）を解消するために、開発ルールを定めることがあります。 たとえば、コーディングスタイルを定義したり（Google C++ Style Guide など）、コードレビューをするなどです。 これらは整形ツールやコーディングチェック（lint）を使って自動化できます。
サーバレスで CI を導入 CI を導入する方法として、CI サーバを立てる方法があります。 たとえば、GitHub では Travis CI を導入することで、git commit 時に自動で CI を実行してくれます。 さらに、CI の実行結果を GitHub のバッジ として公言でき、リポジトリの質を保証する 1 つの指標にできます。
しかし、CI サービスは有料プランのものもあり（Public リポジトリは無料も）、特に社内開発ではコストになる場合があります。 そこで、CI をローカル環境に導入し、git commit 時に自動でコーディングチェックと自動整形をしたいと思います。
huskey と lint-staged を使うメリット コミット時に CI スクリプトを実行するには pre-commit を自前で記述することも可能です。 しかし、ほかの人と共同開発する場合では手動で pre-commit および自動整形ツール（prettier や eslint）を導入する必要がありました。
そこで、husky を使って pre-commit をフックし、lint-staged でコーディングチェックと自動整形を実行させたいと思います。 リポジトリ直下に npm で husky、lint-staged、prettier、eslint などをインストールすれば、以降は npm install だけで CI 環境が整います。...</p></section><footer class=entry-footer>1 min&nbsp;·&nbsp;Tomoyuki Hata</footer><a class=entry-link aria-label="post link to 【アーカイブ】【PHPMD 対応】husky &amp;amp; lint-staged で CI を実行する" href=https://b-hood.site/articles/husky/></a></article><footer class=page-footer><nav class=pagination><a class=prev href=/articles/>« 前のページ</a>
<a class=next href=/articles/page/3/>次のページ »</a></nav></footer></main><footer class=footer><span>&copy; 2020 <a href=https://b-hood.site/>B-Hood Tech Blog</a></span>
<span>&#183;</span>
<span>Powered by <a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a></span>
<span>&#183;</span>
<span>Theme <a href=https://git.io/hugopapermod rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top" accesskey=g><button class=top-link id=top-link type=button><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6"><path d="M12 6H0l6-6z"/></svg></button></a>
<script defer src=https://b-hood.site/assets/js/highlight.min.27cd435cc9ed6abb4b496581b151804f79f366c412620272bb94e2f5f598ebcc.js integrity="sha256-J81DXMntartLSWWBsVGAT3nzZsQSYgJyu5Ti9fWY68w=" onload=hljs.initHighlightingOnLoad();></script><script>window.onload=function(){if(localStorage.getItem("menu-scroll-position")){document.getElementById('menu').scrollLeft=localStorage.getItem("menu-scroll-position");}}
document.querySelectorAll('a[href^="#"]').forEach(anchor=>{anchor.addEventListener("click",function(e){e.preventDefault();var id=this.getAttribute("href").substr(1);document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({behavior:"smooth"});});});var mybutton=document.getElementById("top-link");window.onscroll=function(){if(document.body.scrollTop>800||document.documentElement.scrollTop>800){mybutton.style.visibility="visible";mybutton.style.opacity="1";}else{mybutton.style.visibility="hidden";mybutton.style.opacity="0";}};function menu_on_scroll(){localStorage.setItem("menu-scroll-position",document.getElementById('menu').scrollLeft);}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{if(document.body.className.includes("dark")){document.body.classList.remove('dark');localStorage.setItem("pref-theme",'light');}else{document.body.classList.add('dark');localStorage.setItem("pref-theme",'dark');}})</script></body></html>