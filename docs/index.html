<!DOCTYPE html>
<html lang="en" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name=" robots" content="noindex, nofollow">
<title>hata6502 Tech Blog</title>

<meta name="keywords" content="" />
<meta name="description" content="">
<meta name="author" content="">
<link rel="canonical" href="https://b-hood.site/" />
<link href="https://b-hood.site/assets/css/stylesheet.min.08d6f2005b6ce4ed10207916c0411c66e66f2201e3f7a56e8fb2ccbc4a8b259c.css" integrity="sha256-CNbyAFts5O0QIHkWwEEcZuZvIgHj96Vuj7LMvEqLJZw=" rel="preload stylesheet"
    as="style">

<link rel="icon" href="https://b-hood.site/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="https://b-hood.site/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="https://b-hood.site/favicon-32x32.png">
<link rel="apple-touch-icon" href="https://b-hood.site/apple-touch-icon.png">
<link rel="mask-icon" href="https://b-hood.site/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<meta name="generator" content="Hugo 0.78.2" />
<link rel="alternate" type="application/rss&#43;xml" href="https://b-hood.site/index.xml">




</head>

<body class="list home" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>
<noscript>
    <style type="text/css">
        .theme-toggle,
        .top-link {
            display: none;
        }

    </style>
</noscript>
<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="https://b-hood.site/" accesskey="h">hata6502 Tech Blog</a>
            <span class="logo-switches">
                <span class="theme-toggle">
                    <a id="theme-toggle" accesskey="t">
                        <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"
                            fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                            stroke-linejoin="round">
                            <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                        </svg>
                        <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"
                            fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                            stroke-linejoin="round">
                            <circle cx="12" cy="12" r="5"></circle>
                            <line x1="12" y1="1" x2="12" y2="3"></line>
                            <line x1="12" y1="21" x2="12" y2="23"></line>
                            <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                            <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                            <line x1="1" y1="12" x2="3" y2="12"></line>
                            <line x1="21" y1="12" x2="23" y2="12"></line>
                            <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                            <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                        </svg>
                    </a>
                </span>
                
            </span>
        </div>
        <ul class="menu" id="menu" onscroll="menu_on_scroll()"></ul>
    </nav>
</header>

    <main class="main"> 



<article class="first-entry"> 

  <header class="entry-header">
    <h2>
      VSCode で true と false の色分け
    </h2>
  </header>
  <section class="entry-content">
    <p>boolean の mapping を書くと true と false が見づらいため、 VSCode で true を緑、false を 赤 で表示して見やすくします。
settings.json
&#34;editor.tokenColorCustomizations&#34;: { &#34;textMateRules&#34;: [ { &#34;scope&#34;: &#34;constant.language.boolean.false&#34;, &#34;settings&#34;: { &#34;foreground&#34;: &#34;#D3569B&#34; } }, { &#34;scope&#34;: &#34;constant.language.boolean.true&#34;, &#34;settings&#34;: { &#34;foreground&#34;: &#34;#9BD356&#34; } }, ] } ...</p>
  </section>
  <footer class="entry-footer">November 21, 2020
</footer>
  <a class="entry-link" aria-label="post link to VSCode で true と false の色分け" href="https://b-hood.site/articles/vscode-boolean-colorize/"></a>
</article>
<article class="post-entry"> 

  <header class="entry-header">
    <h2>
      browserslist-config-google でモダンブラウザ向け最適化をする
    </h2>
  </header>
  <section class="entry-content">
    <p>browserslist のデフォルトは、IE 11 も含まれていてさすがにモダンじゃないなーと感じます。 個人的には Babel だけで自動的に IE 対応することは難しいと考えているため、 いっそのこと browserslist からレガシーブラウザを切り捨てます。
$ browserslist &#34;defaults&#34; and_chr 85 and_ff 79 and_qq 10.4 and_uc 12.12 android 81 baidu 7.12 chrome 86 chrome 85 chrome 84 edge 86 edge 85 firefox 82 firefox 81 firefox 80 firefox 78 ie 11 ios_saf 14 ios_saf 13.4-13.7 ios_saf 13.3 ios_saf 12.2-12.4 kaios 2.5 op_mini all op_mob 59 opera 71 opera 70 safari 14 safari 13.1 samsung 12....</p>
  </section>
  <footer class="entry-footer">November 4, 2020
</footer>
  <a class="entry-link" aria-label="post link to browserslist-config-google でモダンブラウザ向け最適化をする" href="https://b-hood.site/articles/browserslist-config-google/"></a>
</article>
<article class="post-entry"> 

  <header class="entry-header">
    <h2>
      【アーカイブ】How to make grid layout in Editor.js
    </h2>
  </header>
  <section class="entry-content">
    <p>&lt;ins class=“adsbygoogle” style=“display:block&#34;ｌｓ data-ad-client=“ca-pub-7008780049786244” data-ad-slot=“5063315418” data-ad-format=“auto” data-full-width-responsive=“true”&gt;Use Editor.js more flexibly Editor.js is one of block editors. The article data format is JSON not HTML, so it can manage article data more cleanly and formally.
Editor.js can’t nest blocks to keep simplicity. So it is useful for general articles that blogs, news and so on. But difficult for special layout that landing page and so on.
Therefore, I published a grid layout plugin for Editor....</p>
  </section>
  <footer class="entry-footer">
</footer>
  <a class="entry-link" aria-label="post link to 【アーカイブ】How to make grid layout in Editor.js" href="https://b-hood.site/articles/editor-js-grid/"></a>
</article>
<article class="post-entry"> 

  <header class="entry-header">
    <h2>
      【アーカイブ】ImageMagickで16:9トリミングを自動化
    </h2>
  </header>
  <section class="entry-content">
    <p>皆さんは画像を SNS や自身のブログなどに投稿する際に加工したことはないでしょうか？ Twitter では画像が自動的に 16:9 で表示されるため、あらかじめ 16:9 でトリミングしておくことでどのように表示されるかを調整できます。 トリミング機能は Android 版にはありますが Web 版にはないため、PC からの画像投稿のときに少し面倒に感じたりします。
画像編集の自動化といえば ImageMagick そこで GIMP などの画像編集ソフトが必要になりますが、私は ImageMagick を利用しています。 画像の加工を自動で行うためのコマンドラインが用意されており、たとえば以下のようにすれば png ファイルを一括で余白トリミングできます。 GIMP でいう「最小枠で切り抜き」機能ですね。
画像サイズを指定しての切り抜きは ImageMagick の crop オプションを使います。 座標 (X, Y) の位置で幅 W px、高さ H px のトリミングをするには以下のコマンドを打ちます。
しかし、残念ながら比率（16:9 など）の指定によるトリミングには対応していません。 そこで、比率指定によるトリミングのコマンドをシェルスクリプトで作りました。
trimrate コマンドを作ってみた 結論から言うと、比率指定によるトリミングコマンドを以下のように作りました。
このシェルスクリプトを trimrate というファイル名で保存します。 保存先は /usr/local/bin などのパスが通っているところが便利です。 そして chmod &#43;x trimrate で実行権限を与えて以下の構文でトリミングを行います。
コマンドの動作的には、比率から切り抜きの幅高さを計算して ImageMagick の crop 機能を呼び出しているだけです。 デフォルトだと画像の上部でトリミングするため、-gravity center オプションを加えて中央でトリミングしています。
for 文で一括処理する trimrate コマンドだけだと mogrify のように複数のファイルを一括処理できません。 しかし、bash の for 文で画像ファイルごとに trimrate を実行して一括処理させることはできます。...</p>
  </section>
  <footer class="entry-footer">
</footer>
  <a class="entry-link" aria-label="post link to 【アーカイブ】ImageMagickで16:9トリミングを自動化" href="https://b-hood.site/articles/trimrate/"></a>
</article>
<article class="post-entry"> 

  <header class="entry-header">
    <h2>
      【アーカイブ】webp 画像形式でファイルサイズが 92% 削減された
    </h2>
  </header>
  <section class="entry-content">
    <p>皆さんこんにちは 😀 私はいま作っているこのサイトでは、シンプルかつこだわりをもってあれこれやっているつもりです。 そのひとつとして、Google の PageSpeed Insightsというものを利用しています。 これはページの読み込み速度をスコアリングして、さらにスピードを改善するためのアドバイスもしてくれるすばらしいツールです。 ページスピードは Web 検索にも影響すると言われ、サイトを運営している方であれば多くの人が活用できるのではないでしょうか？ この記事では、読み込み速度改善の 1 つとしてWebp 画像形式の導入について紹介したいと思います。
まずはページスピードを測定 まずは自分の Web サイトの状況を確認するために、PageSpeed Insights を使います。 サイトの URL を入力して測定するだけで、数十秒後にはスコアが表示されると思います。 なお、PageSpeed Insights はモバイルと PC に分けて測定、スコアリングするため、両方確認する必要があります。
私のサイトでは、まず重要な箇所としてランディングページ (LP) の測定をしてみました。 LP には特にコンテンツもなく負荷が軽いので、スコア 90 点超えの良い結果となりました。
しかし、記事一覧ページでは 80 点台という標準的な結果でした。
こんなとき、Google はスピード改善のための提案をしてくれます。 そこに「次世代フォーマットでの画像の配信」というものがありました。 これは、Web サイトに埋め込まれている jpg や png などの形式の画像を、 jpeg2000 や Webp という画像形式に置き換えることで通信負荷が抑えられることを意味しています。 さらに、次世代フォーマットを導入することによるファイルサイズの削減量まで教えてくれるといういたわり尽くせリです。
Webp 形式に変換する というわけで、さっそく Web サイト中のあらゆる png, JPEG ファイルを Webp に変換してみました。 Ubuntu をお使いの方は、以下のコマンドで Webp に変換するコマンドをインストールできます。
そして、以下のコマンドで png, JPEG ファイルを一括で Webp ファイルに変換できます。 なお、cwebp コマンドは変換のクオリティがデフォルトで 80% に設定されています。 コマンドオプションを追加して、クオリティを変更することも可能です。...</p>
  </section>
  <footer class="entry-footer">
</footer>
  <a class="entry-link" aria-label="post link to 【アーカイブ】webp 画像形式でファイルサイズが 92% 削減された" href="https://b-hood.site/articles/webp/"></a>
</article>
<article class="post-entry"> 

  <header class="entry-header">
    <h2>
      【アーカイブ】「静的サイトジェネレータ」という言葉だけで静的サイトを作った話
    </h2>
  </header>
  <section class="entry-content">
    <p>皆さんこんにちは。 私はつい最近静的サイトジェネレータという言葉を聞きました。 「静的」に興味を惹かれた私が、静的サイトジェネレータという言葉だけで静的サイトを作ってみた話をまとめます。 今回の記事は私の憶測が多いのでご注意ください（笑）
なお、当サイトはこの記事の通りに Laravel &amp; wget &amp; nginx による静的サイトとなっています。 もしご興味があれば、GitHubを見ていただけると幸いです。
静的サイトとは？ まず、静的サイトの意味から考える必要があります。 おそらくこれは静的なサイト、つまりリクエストに対して Web サーバのレスポンスコンテンツが変わらないということです。 ということは、HTML, CSS, 画像アセットなどの静的なファイルを提供するだけのサイトであれば広義の静的サイトに当てはまります。
静的サイトのメリット・デメリット ただ html を提供するだけの静的サイトであれば、なんだかインターネット初期の ‘90 年代のように感じてしまいます。 そこで、静的サイトのメリットをまとめてみました。
 Web サーバが PHP などを実行することはないため、動的コンテンツによる脆弱性が存在しない。 すでにレスポンスコンテンツが用意されているため、高速である。 レンタルサーバなどでは PHP を実行できない場合も多く、静的サイトであればサーバに求める要件が低い。  次に、静的サイトのデメリットをまとめます。
 端末（スマートフォン、PC など）によってサーバレスポンスを変化させることは難しい。 REST API や検索機能などの提供は不可能。  静的サイトジェネレータとは？ 静的サイトの意味が定まったところで、次は静的サイトジェネレータについて考えます。 これは静的サイトを作る、つまり静的サイトを作る元データがあり、それを加工して静的コンテンツを作るツールと考えられます。 ということは PHP で動的コンテンツを作り、それを php コマンドで html 出力して Web サーバで公開すれば、 PHP は静的サイトジェネレータになるということです。 逆に、アクセスがあった時点で PHP を実行して html を出力するのであれば、PHP は動的サイトのエンジンやエグゼキュータと呼べるのでしょう。
クローラは静的サイトジェネレータ？ 以上のことを踏まえると、どんな動的コンテンツでも、サーバからダウンロードしたときには静的コンテンツになっていることになります。 JavaScript による DOM 操作などは、サーバとしては静的であるとみなします。 よって、ローカルな開発環境で動的サイトのサーバを立ち上げ、それをクローラで html として取得すれば、 クローラは静的サイトジェネレータということになります。...</p>
  </section>
  <footer class="entry-footer">
</footer>
  <a class="entry-link" aria-label="post link to 【アーカイブ】「静的サイトジェネレータ」という言葉だけで静的サイトを作った話" href="https://b-hood.site/articles/staticgen/"></a>
</article>
<article class="post-entry"> 

  <header class="entry-header">
    <h2>
      【アーカイブ】【CI】git commit 時に自動整形 &amp; コーディングチェックする
    </h2>
  </header>
  <section class="entry-content">
    <p>皆さんこんにちは。 プログラミングやコーディングを続けていくうちに、過去に自分が書いたコードの意味が分からなくなったりしたことはないでしょうか？ 今回は、中〜大規模な開発をする際に重要な**サーバレスな継続的インテグレーション（CI）**について書きたいと思います。
導入方法はこちら
継続的インテグレーション（CI）とは WikiPedia継続的インテグレーション（CI）とは、ソフトウェア開発においてソースコードの品質や保守性を保ち、持続可能な開発を続けていくための方法です。 つまり、ほかの人が見ても理解しやすく、また自分が書いた古いコードでも処理内容が理解できるようにプログラミングしていくということですね。
個人の趣味のスクリプトであれば CI を導入する必要はないかもしれません。 しかし、お仕事などでのチームでの開発では重要になると思います。 また GitHub で公開するものに対しても、CI を導入するとメリットが大きいと思います。
ソースコードの属人性（その人にしか分からないような書き方）を解消するために、開発ルールを定めることがあります。 たとえば、コーディングスタイルを定義したり（Google C&#43;&#43; Style Guide など）、コードレビューをするなどです。 これらは整形ツールやコーディングチェック（lint）を使って自動化できます。
サーバレスで CI を導入 CI を導入する方法として、CI サーバを立てる方法があります。 たとえば、GitHub では Travis CI を導入することで、git commit 時に自動で CI を実行してくれます。 さらに、CI の実行結果を GitHub のバッジ として公言でき、リポジトリの質を保証する 1 つの指標にできます。
しかし、CI サービスは有料プランのものもあり（Public リポジトリは無料も）、特に社内開発ではコストになる場合があります。 そこで、CI をローカル環境に導入し、git commit 時に自動でコーディングチェックと自動整形をしたいと思います。
pre_commit フックを使う Git には、コミット時などにスクリプトを実行するフック機能があります。 その 1 つに pre_commit というものがあり、これはコミットをする直前に発動します。 よって、pre_commit に CI のプログラムを記述することで、git commit したときにコーディングチェックや自動整形を実行できます。
自動化ツール コーディングチェックや自動整形を行うコマンドラインツールです。
 clang-format　C/C&#43;&#43; の自動整形をします。 cpplint　C/C&#43;&#43; の静的コード解析をします。 Prettier　HTML, CSS, JavaScript, PHP, Markdown, Yaml などの自動整形をします。 ESLint　JavaScript の静的コード解析をします。 phpmd　PHP の静的コード解析をします。  pre_commit 例 私が開発するときに導入している Git フックは、このリポジトリで公開しています。 blue-hood/....</p>
  </section>
  <footer class="entry-footer">
</footer>
  <a class="entry-link" aria-label="post link to 【アーカイブ】【CI】git commit 時に自動整形 &amp; コーディングチェックする" href="https://b-hood.site/articles/pre_commit/"></a>
</article>
<article class="post-entry"> 

  <header class="entry-header">
    <h2>
      【アーカイブ】【Git×Twitter】連携 &amp;amp; 通知してコミットの質を上げよう
    </h2>
  </header>
  <section class="entry-content">
    <p>いつも私は Git のコミットメッセージを適当に済ませてしまうのですが、git push するとツイートされるしくみを導入したらコミットメッセージの質が格段に上がりました。
導入前
導入後
（英語から日本語に変わっているのはさておき、）コミットメッセージの内容が具体的になりました。また、Twitter を意識してかちょっと感情的なところもちらほらありますね。このような Git と Twitter の連携をサーバレスで導入する方法を紹介します。
インストール方法
2019/03/30 gitwitter のレアケース対策をしました。
Webhook は意外と不便 Git と Twitter の連携でメジャーと思われるのは、Webhook を利用する方法です。GitHub や Bitbucket には、リポジトリへの push イベントごとに POST リクエストを投げてくれる機能があります。それを別途 Web サーバで拾ってツイートします。いわゆるクラウドハブはこの機能を利用しているわけですね。
しかし、クラウドハブを利用するには月額料金がかかったり、無料だとしても月ごとの使用回数に制限があったりします。また自前で Webhook を拾うには、サーバが必要なのはもちろん HTTPS 通信をするためのドメインと証明書なども必要になります。Git の push をツイートするためだけに Webhook を利用するのは、ちょっとオーバーな気がします。
また、実際に私が Webhook を導入してみて思ったのは、ツイートするかを毎回制御できないため不便だということです。たとえば、タイポを修正するだけのささいな push に対してもツイートされてしまい、手動で無駄なツイートを消すということがありました。タイムラインを荒らしてしまったと思いますね。
サーバレスで連携する そこで、Webhook を使わずクライアントで動かす連携アプリケーションを作ることにしました。これならサーバレスだしツイートするかも毎回決めることができます。ツイートする文章はシェルスクリプトで git log を呼び出したりして組み立てました。ツイートするには TwitterOAuth を使って Twitter REST API をたたく PHP スクリプトを書きました。使い方はこんな感じです。
tweet コマンド GitHub: Hata6502/tweet
コマンドラインからツイートします。標準入力から読み込む汎用的な作りにしたので、Git との連携以外にも応用できるかもしれません。
(1) /usr/local/src などにダウンロードします。...</p>
  </section>
  <footer class="entry-footer">
</footer>
  <a class="entry-link" aria-label="post link to 【アーカイブ】【Git×Twitter】連携 &amp;amp; 通知してコミットの質を上げよう" href="https://b-hood.site/articles/gitwitter/"></a>
</article>
<article class="post-entry"> 

  <header class="entry-header">
    <h2>
      【アーカイブ】【jQuery不要】JS で章番号 &amp; リンク付きの目次を自動生成する
    </h2>
  </header>
  <section class="entry-content">
    <p>WordPress 製のサイトなどで見かける目次。 そのページの内容がリストとして一目で確認できるため、Web サイトにも大きな役割を果たします。 JavaScript で目次を自動生成する方法を紹介します。
JavaScript で目次を作る 基本的に見出しは h1〜h6 でタグ付けされているかと思います。 これらのタグには見出しという情報だけでなく、見出しどうしの階層関係も表現されています。 よって、h1〜h6 タグは目次を作るのに最適な情報源と言えます。
目次を置く場所に &lt;ol class=&#34;table-of-contents&#34;&gt;&lt;/ol&gt; を配置して、この要素の中に JavaScript で目次の情報を書き込んでいきます。
上記が目次を自動生成する JavaScript の完成形になります。
QuerySelectorAll で h1〜h6 タグを探す まずは .table-of-contents を設置した親要素から、h1〜h6 要素を探し出します。
h1〜h6 タグを元に目次要素を生成 探し出した h1〜h6 タグが変数 heading に入ってループ処理されているとします。 まずは目次 1 行分に相当する li 要素を生成し、その中に a 要素と ol 要素を入れています。 a 要素には h1〜h6 のテキストを入れて、さらにアンカーリンクとして href 属性に #section-${table_of_contents_counter&#43;&#43;} を入れています。 変数 table_of_contents_counter は 1、2、3…と増分していくので、生成されるアンカーリンクも #section-1、#section-2、…となります。 ol 要素は、見出しの階層構造を作るために後で必要となります。
h1〜h6 タグにアンカーリンクも紐付け 生成したアンカーリンクを h1〜h6 タグの id に設定します。 これによって、目次の要素をクリックしたときにページ内ジャンプさせます。 さらに、必要であれば anchor-link クラスを付けて CSS でデザイン調整しましょう。...</p>
  </section>
  <footer class="entry-footer">
</footer>
  <a class="entry-link" aria-label="post link to 【アーカイブ】【jQuery不要】JS で章番号 &amp; リンク付きの目次を自動生成する" href="https://b-hood.site/articles/table-of-contents/"></a>
</article>
<article class="post-entry"> 

  <header class="entry-header">
    <h2>
      【アーカイブ】【PHPMD 対応】husky &amp;amp; lint-staged で CI を実行する
    </h2>
  </header>
  <section class="entry-content">
    <p>みなさんこんにちは、今回は husky と lint-staged を使って CI 環境をローカルに構築する方法を紹介したいと思います。
継続的インテグレーション（CI）とは WikiPedia継続的インテグレーション（CI）とは、ソフトウェア開発においてソースコードの品質や保守性を保ち、持続可能な開発を続けていくための方法です。 つまり、ほかの人が見ても理解しやすく、また自分が書いた古いコードでも処理内容が理解できるようにプログラミングしていくということですね。
個人の趣味のスクリプトであれば CI を導入する必要はないかもしれませんが、お仕事などでのチームでの開発では重要になると思います。 また GitHub で公開するものに対しても、CI を導入するとメリットが大きいと思います。
ソースコードの属人性（その人にしか分からないような書き方）を解消するために、開発ルールを定めることがあります。 たとえば、コーディングスタイルを定義したり（Google C&#43;&#43; Style Guide など）、コードレビューをするなどです。 これらは整形ツールやコーディングチェック（lint）を使って自動化できます。
サーバレスで CI を導入 CI を導入する方法として、CI サーバを立てる方法があります。 たとえば、GitHub では Travis CI を導入することで、git commit 時に自動で CI を実行してくれます。 さらに、CI の実行結果を GitHub のバッジ として公言でき、リポジトリの質を保証する 1 つの指標にできます。
しかし、CI サービスは有料プランのものもあり（Public リポジトリは無料も）、特に社内開発ではコストになる場合があります。 そこで、CI をローカル環境に導入し、git commit 時に自動でコーディングチェックと自動整形をしたいと思います。
huskey と lint-staged を使うメリット コミット時に CI スクリプトを実行するには pre-commit を自前で記述することも可能です。 しかし、ほかの人と共同開発する場合では手動で pre-commit および自動整形ツール（prettier や eslint）を導入する必要がありました。
そこで、husky を使って pre-commit をフックし、lint-staged でコーディングチェックと自動整形を実行させたいと思います。 リポジトリ直下に npm で husky、lint-staged、prettier、eslint などをインストールすれば、以降は npm install だけで CI 環境が整います。...</p>
  </section>
  <footer class="entry-footer">
</footer>
  <a class="entry-link" aria-label="post link to 【アーカイブ】【PHPMD 対応】husky &amp;amp; lint-staged で CI を実行する" href="https://b-hood.site/articles/husky/"></a>
</article>
<footer class="page-footer">
  <nav class="pagination">
    <a class="next" href="/page/2/">Next Page »</a>
  </nav>
</footer>

    </main><footer class="footer">
    <span>&copy; 2020 <a href="https://b-hood.site/">hata6502 Tech Blog</a></span>
    <span>&middot;</span>
    <span>Powered by <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a></span>
    <span>&middot;</span>
    <span>Theme <a href="https://git.io/hugopapermod" rel="noopener" target="_blank">PaperMod</a></span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top" accesskey="g">
    <button class="top-link" id="top-link" type="button">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6">
            <path d="M12 6H0l6-6z" /></svg>
    </button>
</a>



<script>
    window.onload = function () {
        if (localStorage.getItem("menu-scroll-position")) {
            document.getElementById('menu').scrollLeft = localStorage.getItem("menu-scroll-position");
        }
    }
    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                behavior: "smooth"
            });
        });
    });
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

    function menu_on_scroll() {
        localStorage.setItem("menu-scroll-position", document.getElementById('menu').scrollLeft);
    }

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>

</body>

</html>
